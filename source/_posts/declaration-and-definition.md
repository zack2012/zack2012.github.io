---
title: 声明和定义的区别
mathjax: false
date: 2018-11-24 09:45:46
categories: 编程语言
tags: 
    - c++
    - objective-c
---

一个大型app通常有许多库组成，在参与大型app的开发时，我们应该掌握声明与定义的区别，同时对ABI稳定有一定的了解。

<!-- more -->

## 1. 变量声明与定义

很多时候，我们在写代码时并没有注意到变量的声明和定义是有区别的，比如：

```c++
int i = 0;
```

上面的代码同时声明和定义了变量i，但如果把这行代码放在.h文件里，声明和定义的区别就会显示出来，会在link阶段报duplicate symbols错误。那么声明和定义变量的区别在哪里？最大的区别在于声明变量时只向程序表明了该变量的类型和名字，但不分配内存。定义变量的时候不仅声明了该变量，还为该变量分配了内存。程序中可以声明变量多次，但只能定义一次。如果我们定义变量多次就会报plicate symbols错误。

因为.h文件会被多个文件引用，所以我们在.h文件里要声明变量，而不定义变量。代码如下：

```c++
// a.h
extern int i;

// a.{c, cpp, m, mm}
int i = 10;
```

通过在变量i前添加extern关键字来表示这是个声明。注意如果同时对这个变量进行了初始化，则变成了定义，例如:

```cpp
extern int i = 10; // 定义
```

## 2. 外部连接和内部连接

在介绍外部链接和内部链接前，需要先了解什么是编译单元：

当一个.{c,cpp,m,mm}文件在编译时，预处理器首先递归包含.h文件，形成一个含有所有必要信息的单个源文件,这个源文件就是一个编译单元。link程序会把不同编译单元中产生的符号联系起来，构成一个可执行程序。

一个名称(变量、函数名、类等)在连接时可以和其它编译单元交互，那么这个名称就有外部连接。有了外部连接，就意味着这个名称存在与其他编译单元里的名称冲突等可能，这里最常见的一个坑就是认为没在.h文件声明变量，就不会暴露，例如：

```cpp
// a.{c,cpp,m,mm}
int j = 10; // 编译器在编译时，会在前面加上extern，因此其他编译单元里如果定义了同样的变量，link时就会报错。
```

一个名称对于它的编译单元来说是局部的，并且在连接时不会与其它编译单元中的同样的名称相冲突，那么这个名称有内部连接。内部连接不会污染全局名称，我们可以通过如下方式声明内部连接变量：

```cpp
// a.{c,cpp,m,mm}
static int j = 10; 

// 对于c++，还可以使用匿名空间方式定义内部连接
namespace {
    int j = 10;
}
```

`static`关键字可以把名称声明为内部连接，其在不同的场合有着不同的作用，例如定义静态变量。在c++里，匿名空间里的声明都是内部连接，c++使用这种方式定义内部连接的好处是更加简洁，不容易出错(不需要在每个声明前加上static)，如果与外部变量冲突，使用`static`会屏蔽掉外部全局变量，而使用匿名空间则编译不过去，报Reference to 'xxx' is ambiguous错误，而且没有可以直接绕过的方法，例如：

```cpp
// a.h
extern int j;

// a.cpp
int j = 10;

// b.cpp
namespace {
    int j = 100
    // 如果遇到与全局变量冲突，可以由以下几种方式绕过
    int getJ() {
        return j;
    }

    int &localJ = ::j;
};

void foo() {
    std::cout << j << "\n" // error: reference to 'j' is ambiguous
    std::cout << ::j << "\n" // 输出10
    std::cout << getJ() << " " << localJ << "\n" // 输出 100 100
}
```
这里可以看到，使用全局变量是万恶之源。不要在.h文件里声明内部连接变量，例如：

```cpp
// a.h
static int i = 10; // 不要在.h文件里这样做!

// 不要在.h文件里这样做!
namespace {
    int j = 100; 
};
```
当多个编译单元包含上面.h文件时，会在每个编译单元内都定义变量i，j。这些变量是相互独立的，有着不同的内存地址。例如：

```cpp
static int i = 10; // 不要在.h文件里这样做!

// 不要在.h文件里这样做!
namespace {
    int j = 100; 
};

// b.h
int foo;

// b.{c,cpp,m,mm}
#include "a.h"

int foo() {
    i = 100;
    return i;
}

// c.{c,cpp,m,mm}
#include "a.h"

int bar() {
    return i;
}

// main.cpp
int main(int argc, const char * argv[]) {
    std::cout << foo() << " " << bar() << "\n"; // 输出 100 10
    return 0;
}
```
虽然看上去像每个编译单元都共享同一个变量定义，但实际上每个变量都是独立的。也许有人会说，如果用上述方法定义常量呢，这样就不存在上面的问题了。例如：

```cpp
static const int i = 10; // 不要在.h文件里这样做!

// 不要在.h文件里这样做!
namespace {
    const int j = 100; 
};
```
这么定义常量还是有问题的，第一个问题是会引起最终二进制代码膨胀，假设有100个文件引用了，就需要分配100个同样大小的内存空间，这完全是没有必要的。第二个问题是ABI不稳定，这放到下节讨论。

## 3. ABI稳定

很多人都知道API(Application Programming Interface)，但可能并不知道ABI(Application Binary Interface)。ABI中文翻译为二进制接口，我们知道，一个库最终会生成二进制文件，ABI就是描述二进制库之间的接口关系，它的范围很广，例如函数的调用约定(calling convention)，数据结构布局等。

ABI不稳定会有什么问题？ABI不稳定意味着我们不能对外提供二进制库，只能提供源码库。例如，有两个库A和B，B依赖于A，App主工程同时依赖A、B，一天，A发布了新版本，如果ABI稳定的话，我们重新打包App时并不需要重新编译B库，但ABI不稳定的话，我们还要重新编译B库才行。最典型的例子就是swift，因为swift ABI不稳定，每个使用swift编写的app都必须把swift的核心库打进包里，这不仅阻碍了swift的普及(大厂对app包大小有着严格的限制，哪怕整个app只有一个文件是用swift编写的，也会使包的大小增加几M，这对大厂来说是无法接受的)，也使Apple自身无法发布用swift编写的库。

对于中小型app来说，其实并不需要太关心abi稳定，中小型app通常都是在一个工程里把所有库的源码都引入一起编译，因为app规模不大，这样做的成本并不高。但对于大型app，这样做就行不通了。

大型app的开发一般有如下特点：
- app的主工程为一个空壳，几乎不含有任何代码
- app由非常多的组建库组成，一些组建库被许多组建库所引用，有时你甚至不知道哪些库引用了你(当然我们可以通过分析mach文件来查询哪些库引用了你，比如[MachOView](https://github.com/gdbinit/MachOView)就是一个很好的工具)
- 在一次迭代周期中，往往只有少量的库被更新编译，重新打包，更多的库都是直接使用上个版本的二进制。

因此，在大型app开发过程中，ABI稳定就显得格外重要了，下面介绍常见的几个注意点。

### 3.1 对外暴露的.h文件里不要使用宏

这点很好理解，宏在预处理阶段会进行字符串替换，所以编译完后的库实质上就是写死了一段代码。对宏的修改想要生效，所有依赖库都必须重新编译打包。例如，有A、B两个库，在A库对外的.h文件里定义了一个常量：

```cpp
#define FOO 3
```
B库引用了A库，在一次迭代中，A库根据需求，需要把常量FOO改为4，那作为A库维护者，他必须通知B库的维护者用最新的A库重新编译打包。试想一下，如果有50个库引用了A库，那A库的维护者就要一个一个去通知，这个工作量和时间成本可想可知。

### 3.2 对外暴露的.h文件里不要使用enum

不使用宏很好理解，但对于enum，很多人就会忽略了，本质上使用宏跟使用enum是一样的。例如下面一段代码写在对外暴露的.h文件里：

```objc
typedef NS_ENUM(NSUInteger, Color) {
    ColorRed,
    ColorBlue,
    ColorOthers
};
```
在一次需求迭代中，这个enum添加了一个新的颜色：

```objc
typedef NS_ENUM(NSUInteger, Color) {
    ColorRed,
    ColorBlue,
    ColorYellow,
    ColorOthers
};
```
那所有使用ColorOthers且并未重新编译打包的地方都会出现逻辑错误，把ColorYellow当成ColorOthers。原因就是这么写实际上与前面所说的在.h文件声明内部连接变量一样，在每个编译单元里都会重新定义一次Color，这些定义相互独立，因此如果不重新编译打包，ColorOthers的值还是2。所以一旦定义了enum的值，修改起来的成本就与宏一样了。如果必须使用enum，一定保证新引入的值不会改变之前定义的值。上面的论述也同样适用与c++里的enum和enum class。

### 3.3 不要随便使用inline

使用inline与宏一样，将原来的函数或变量在调用地方展开，这样这个函数或变量就成了ABI的一部分。使用inline一般都是为了性能优化，把一个非inline函数改为inline函数是很容易的，但把一个inline函数改成非inline函数就很困难了，我们完全可以等到确定这段代码成为性能瓶颈时在把它改成inline。

swift-evolution里有一个[proposals](https://github.com/apple/swift-evolution/blob/master/proposals/0193-cross-module-inlining-and-specialization.md)专门讲了这个。

## 4. 总结

在日常开发中，我们应该对声明和定义的区别有着清楚的认识，同时也应该对ABI稳定有一定的了解，这样可以避免我们在工作中踩到一些不必要的坑。

